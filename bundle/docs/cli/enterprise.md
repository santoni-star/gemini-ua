# Gemini CLI для підприємств

Цей документ описує патерни налаштування та найкращі практики розгортання й
керування Gemini CLI в корпоративному середовищі. Використовуючи налаштування
системного рівня, адміністратори можуть впроваджувати політики безпеки, керувати
доступом до інструментів та забезпечувати однаковий досвід для всіх
користувачів.

> **Примітка щодо безпеки:** Патерни, описані в цьому документі, призначені
> допомогти адміністраторам створити більш контрольоване та безпечне середовище
> для використання Gemini CLI. Проте їх не слід розглядати як абсолютно надійну
> межу безпеки. Рішучий користувач із достатніми правами на локальній машині все
> одно зможе обійти ці налаштування. Ці заходи призначені для запобігання
> випадковому неправильному використанню та забезпечення дотримання
> корпоративної політики в керованому середовищі, а не для захисту від
> зловмисника з правами локального адміністратора.

## Централізоване налаштування: файл системних налаштувань

Найпотужнішими інструментами для корпоративного адміністрування є
загальносистемні файли налаштувань. Ці файли дозволяють визначити базову
конфігурацію (`system-defaults.json`) та набір перевизначень (`settings.json`),
які застосовуються до всіх користувачів на машині. Повний огляд параметрів
конфігурації дивіться у
[документації з налаштування](../get-started/configuration.md).

Налаштування об'єднуються з чотирьох файлів. Порядок пріоритетності для
поодиноких значень (наприклад, `theme`):

1. Системні значення за замовчуванням (`system-defaults.json`)
2. Налаштування користувача (`~/.gemini/settings.json`)
3. Налаштування робочого простору (`<project>/.gemini/settings.json`)
4. Системні перевизначення (`settings.json`)

Це означає, що файл системних перевизначень має останнє слово. Для налаштувань,
які є масивами (`includeDirectories`) або об'єктами (`mcpServers`), значення
об'єднуються.

**Приклад об'єднання та пріоритетності:**

Ось як поєднуються налаштування різних рівнів.

- **Системні значення за замовчуванням `system-defaults.json`:**

  ```json
  {
    "ui": {
      "theme": "default-corporate-theme"
    },
    "context": {
      "includeDirectories": ["/etc/gemini-cli/common-context"]
    }
  }
  ```

- **Користувач `settings.json` (`~/.gemini/settings.json`):**

  ```json
  {
    "ui": {
      "theme": "user-preferred-dark-theme"
    },
    "mcpServers": {
      "corp-server": {
        "command": "/usr/local/bin/corp-server-dev"
      },
      "user-tool": {
        "command": "npm start --prefix ~/tools/my-tool"
      }
    },
    "context": {
      "includeDirectories": ["~/gemini-context"]
    }
  }
  ```

- **Робочий простір `settings.json` (`<project>/.gemini/settings.json`):**

  ```json
  {
    "ui": {
      "theme": "project-specific-light-theme"
    },
    "mcpServers": {
      "project-tool": {
        "command": "npm start"
      }
    },
    "context": {
      "includeDirectories": ["./project-context"]
    }
  }
  ```

- **Системні перевизначення `settings.json`:**
  ```json
  {
    "ui": {
      "theme": "system-enforced-theme"
    },
    "mcpServers": {
      "corp-server": {
        "command": "/usr/local/bin/corp-server-prod"
      }
    },
    "context": {
      "includeDirectories": ["/etc/gemini-cli/global-context"]
    }
  }
  ```

Це призводить до такої об'єднаної конфігурації:

- **Фінальна об'єднана конфігурація:**
  ```json
  {
    "ui": {
      "theme": "system-enforced-theme"
    },
    "mcpServers": {
      "corp-server": {
        "command": "/usr/local/bin/corp-server-prod"
      },
      "user-tool": {
        "command": "npm start --prefix ~/tools/my-tool"
      },
      "project-tool": {
        "command": "npm start"
      }
    },
    "context": {
      "includeDirectories": [
        "/etc/gemini-cli/common-context",
        "~/gemini-context",
        "./project-context",
        "/etc/gemini-cli/global-context"
      ]
    }
  }
  ```

**Чому так:**

- **`theme`**: Використовується значення з системних перевизначень
  (`system-enforced-theme`), оскільки воно має найвищий пріоритет.
- **`mcpServers`**: Об'єкти об'єднуються. Визначення `corp-server` із системних
  перевизначень має пріоритет над визначенням користувача. Унікальні `user-tool`
  та `project-tool` також включені.
- **`includeDirectories`**: Масиви об'єднуються в порядку: Системні за
  замовчуванням, Користувач, Робочий простір, а потім Системні перевизначення.

- **Розташування**:
  - **Linux**: `/etc/gemini-cli/settings.json`
  - **Windows**: `C:\ProgramData\gemini-cli\settings.json`
  - **macOS**: `/Library/Application Support/GeminiCli/settings.json`
  - Шлях можна змінити за допомогою змінної середовища
    `GEMINI_CLI_SYSTEM_SETTINGS_PATH`.
- **Контроль**: Цей файл має керуватися системними адміністраторами та бути
  захищеним відповідними дозволами файлової системи, щоб запобігти
  несанкціонованим змінам з боку користувачів.

Використовуючи файл системних налаштувань, ви можете впроваджувати патерни
безпеки та конфігурації, описані нижче.

### Застосування системних налаштувань за допомогою сценарію-обгортки

Хоча змінна середовища `GEMINI_CLI_SYSTEM_SETTINGS_PATH` забезпечує гнучкість,
користувач потенційно може змінити її, щоб вона вказувала на інший файл
налаштувань, обходячи централізовану конфігурацію. Щоб запобігти цьому,
підприємства можуть розгорнути сценарій-обгортку (wrapper) або аліас, який
гарантує, що змінна середовища завжди вказує на шлях, контрольований компанією.

Цей підхід гарантує, що незалежно від того, як користувач викликає команду
`gemini-ua`, корпоративні налаштування завжди будуть завантажені з найвищим
пріоритетом.

**Приклад сценарію-обгортки:**

Адміністратори можуть створити скрипт з назвою `gemini-ua` і помістити його в
каталог, який з'являється в `PATH` користувача раніше, ніж справжній бінарний
файл Gemini CLI (наприклад, `/usr/local/bin/gemini-ua`).

```bash
#!/bin/bash

# Примусово встановлюємо шлях до файлу корпоративних системних налаштувань.
# Це гарантує, що конфігурація компанії завжди застосовується.
export GEMINI_CLI_SYSTEM_SETTINGS_PATH="/etc/gemini-cli/settings.json"

# Знаходимо оригінальний виконуваний файл gemini-ua.
# Це простий приклад; може знадобитися більш надійне рішення
# залежно від методу встановлення.
REAL_GEMINI_PATH=$(type -aP gemini-ua | grep -v "^$(type -P gemini-ua)$" | head -n 1)

if [ -z "$REAL_GEMINI_PATH" ]; then
  echo "Помилка: Оригінальний виконуваний файл 'gemini-ua' не знайдено." >&2
  exit 1
fi

# Передаємо всі аргументи справжньому виконуваному файлу Gemini CLI.
exec "$REAL_GEMINI_PATH" "$@"
```

Завдяки цьому сценарію `GEMINI_CLI_SYSTEM_SETTINGS_PATH` встановлюється
всередині середовища скрипта, а команда `exec` замінює процес скрипта реальним
процесом Gemini CLI, який успадковує цю змінну. Це значно ускладнює для
користувача обхід встановлених налаштувань.

## Обмеження доступу до інструментів

Ви можете значно підвищити безпеку, контролюючи, які інструменти може
використовувати модель Gemini. Це досягається за допомогою налаштувань
`tools.core` та `tools.exclude`. Список доступних інструментів дивіться у
[документації з інструментів](../tools/index.md).

### Створення "білого списку" (allowlisting) за допомогою `coreTools`

Найбезпечнішим підходом є явне додавання дозволених інструментів та команд до
білого списку. Це запобігає використанню будь-якого інструменту, якого немає в
затвердженому списку.

**Приклад:** Дозволити лише безпечні операції з файлами (читання та список).

```json
{
  "tools": {
    "core": ["ReadFileTool", "GlobTool", "ShellTool(ls)"]
  }
}
```

### Створення "чорного списку" (blocklisting) за допомогою `excludeTools`

Альтернативно ви можете додати конкретні інструменти, які вважаються
небезпечними у вашому середовищі, до чорного списку.

**Приклад:** Заборонити використання інструменту оболонки для видалення файлів.

```json
{
  "tools": {
    "exclude": ["ShellTool(rm -rf)"]
  }
}
```

**Примітка з безпеки:** Чорний список (`excludeTools`) менш безпечний, ніж білий
список (`coreTools`), оскільки він покладається на блокування відомих шкідливих
комад, і винахідливі користувачі можуть знайти способи обійти прості текстові
блоки. **Рекомендованим підходом є створення білого списку.**

### Вимкнення режиму YOLO

Щоб гарантувати, що користувачі не можуть обійти запит на підтвердження
виконання інструменту, ви можете вимкнути режим YOLO на рівні політики. Це додає
критично важливий рівень безпеки, оскільки запобігає виконанню інструментів
моделлю без явного схвалення користувача.

**Приклад:** Змусити всі виконання інструментів потребувати підтвердження
користувача.

```json
{
  "security": {
    "disableYoloMode": true
  }
}
```

Це налаштування настійно рекомендується в корпоративному середовищі для
запобігання ненавмисному виконанню інструментів.

## Керування власними інструментами (сервери MCP)

Якщо ваша організація використовує власні інструменти через
[сервери Model-Context Protocol (MCP)](../core/tools-api.md), важливо розуміти,
як керувати їхніми конфігураціями для ефективного застосування політик безпеки.

### Як об'єднуються конфігурації серверів MCP

Gemini CLI завантажує файли `settings.json` з трьох рівнів: Системний, Робочий
простір та Користувач. Що стосується об'єкта `mcpServers`, ці конфігурації
**об'єднуються**:

1.  **Об'єднання:** Списки серверів з усіх трьох рівнів об'єднуються в єдиний
    список.
2.  **Пріоритетність:** Якщо сервер з **однаковою назвою** визначений на кількох
    рівнях (наприклад, сервер `corp-api` існує і в системних, і в користувацьких
    налаштуваннях), використовується визначення з найвищого рівня пріоритету.
    Порядок пріоритету: **Система > Робочий простір > Користувач**.

Це означає, що користувач **не може** перевизначити конфігурацію сервера, який
вже визначено в системних налаштуваннях. Проте вони **можуть** додавати нові
сервери з унікальними назвами.

### Впровадження каталогу інструментів

Безпека вашої екосистеми інструментів MCP залежить від поєднання визначення
канонічних серверів та додавання їхніх назв до білого списку.

### Обмеження інструментів у межах сервера MCP

Для ще більшої безпеки, особливо при роботі зі сторонніми серверами MCP, ви
можете обмежити, які саме інструменти сервера будуть доступні моделі. Це
робиться за допомогою властивостей `includeTools` та `excludeTools` у визначенні
сервера. Це дозволяє використовувати лише підмножину інструментів сервера,
забороняючи потенційно небезпечні.

Дотримуючись принципу найменших привілеїв, настійно рекомендується
використовувати `includeTools` для створення білого списку лише необхідних
інструментів.

**Приклад:** Дозволити лише інструменти `code-search` та `get-ticket-details` зі
стороннього MCP сервера, навіть якщо сервер пропонує інші інструменти, як-от
`delete-ticket`.

```json
{
  "mcp": {
    "allowed": ["third-party-analyzer"]
  },
  "mcpServers": {
    "third-party-analyzer": {
      "command": "/usr/local/bin/start-3p-analyzer.sh",
      "includeTools": ["code-search", "get-ticket-details"]
    }
  }
}
```

#### Більш безпечний патерн: визначення та додавання до білого списку в системних налаштуваннях

Щоб створити безпечний, централізовано керований каталог інструментів, системний
адміністратор **має** зробити обидва наступні кроки у системному файлі
`settings.json`:

1.  **Визначити повну конфігурацію** для кожного затвердженого сервера в об'єкті
    `mcpServers`. Це гарантує, що навіть якщо користувач визначить сервер з
    такою ж назвою, безпечне системне визначення матиме пріоритет.
2.  **Додати назви** цих серверів до білого списку за допомогою налаштування
    `mcp.allowed`. Це критичний крок безпеки, який заважає користувачам
    запускати будь-які сервери, яких немає в цьому списку. Якщо пропустити це
    налаштування, CLI об'єднає та дозволить будь-який сервер, визначений
    користувачем.

**Приклад системного `settings.json`:**

1. Додайте _назви_ всіх затверджених серверів до білого списку. Це завадить
   користувачам додавати власні сервери.

2. Надайте канонічне _визначення_ для кожного сервера з білого списку.

```json
{
  "mcp": {
    "allowed": ["corp-data-api", "source-code-analyzer"]
  },
  "mcpServers": {
    "corp-data-api": {
      "command": "/usr/local/bin/start-corp-api.sh",
      "timeout": 5000
    },
    "source-code-analyzer": {
      "command": "/usr/local/bin/start-analyzer.sh"
    }
  }
}
```

Цей патерн є безпечнішим, оскільки використовує і визначення, і білий список.
Будь-який сервер, який визначить користувач, буде або перевизначений системною
конфігурацією (якщо назви збігаються), або заблокований, оскільки його назви
немає у списку `mcp.allowed`.

### Менш безпечний патерн: пропуск білого списку

Якщо адміністратор визначить об'єкт `mcpServers`, але не вкаже білий список
`mcp.allowed`, користувачі зможуть додавати власні сервери.

**Приклад системного `settings.json`:**

Ця конфігурація визначає сервери, але не обмежує білий список. Адміністратор НЕ
включив параметр "mcp.allowed".

```json
{
  "mcpServers": {
    "corp-data-api": {
      "command": "/usr/local/bin/start-corp-api.sh"
    }
  }
}
```

У цьому сценарії користувач може додати власний сервер у свій локальний
`settings.json`. Оскільки списку `mcp.allowed` для фільтрації результатів немає,
сервер користувача буде додано до списку доступних інструментів і дозволено до
запуску.

## Впровадження пісочниці для безпеки

Щоб знизити ризик від потенційно шкідливих операцій, ви можете змусити всіх
користувачів використовувати пісочницю (sandboxing) для виконання інструментів.
Пісочниця ізолює виконання інструментів у контейнеризованому середовищі.

**Приклад:** Змусити всі інструменти виконуватися всередині пісочниці Docker.

```json
{
  "tools": {
    "sandbox": "docker"
  }
}
```

Ви також можете вказати власний, захищений образ Docker для пісочниці,
побудувавши власний `sandbox.Dockerfile`, як описано в
[документації з пісочниці](./sandbox.md).

## Контроль мережевого доступу через проксі

У корпоративних середовищах із суворими мережевими політиками ви можете
налаштувати Gemini CLI на маршрутизацію всього вихідного трафіку через
корпоративний проксі. Це можна встановити через змінну середовища, але також це
можна примусово задати для власних інструментів через конфігурацію `mcpServers`.

**Приклад (для сервера MCP):**

```json
{
  "mcpServers": {
    "proxied-server": {
      "command": "node",
      "args": ["mcp_server.js"],
      "env": {
        "HTTP_PROXY": "http://proxy.example.com:8080",
        "HTTPS_PROXY": "http://proxy.example.com:8080"
      }
    }
  }
}
```

## Телеметрія та аудит

Для цілей аудиту та моніторингу ви можете налаштувати Gemini CLI на надсилання
даних телеметрії в центральне місце. Це дозволяє відстежувати використання
інструментів та інші події. Докладніше дивіться у
[документації з телеметрії](./telemetry.md).

**Приклад:** Увімкнути телеметрію та надсилати її в локальний колектор OTLP.
Якщо `otlpEndpoint` не вказано, типовим значенням є `http://localhost:4317`.

```json
{
  "telemetry": {
    "enabled": true,
    "target": "gcp",
    "logPrompts": false
  }
}
```

**Примітка:** Переконайтеся, що `logPrompts` встановлено у `false` в
корпоративних налаштуваннях, щоб уникнути збору потенційно конфіденційної
інформації з підказок користувачів.

## Аутентифікація

Ви можете встановити конкретний метод аутентифікації для всіх користувачів,
задавши `enforcedAuthType` у системному файлі `settings.json`. Це завадить
користувачам обирати інший метод. Дивіться
[документацію з аутентифікації](./authentication.md) для отримання детальної
інформації.

**Приклад:** Примусово використовувати вхід через Google для всіх користувачів.

```json
{
  "enforcedAuthType": "oauth-personal"
}
```

Якщо у користувача налаштований інший метод, йому буде запропоновано перейти на
встановлений. У неінтерактивному режимі CLI завершить роботу з помилкою, якщо
налаштований метод не збігається з примусово встановленим.

### Обмеження входу корпоративними доменами

Для підприємств, що використовують Google Workspace, ви можете встановити
правило, згідно з яким користувачі можуть авторизуватися лише зі своїх
корпоративних облікових записів Google. Це контроль на рівні мережі, який
налаштовується на проксі-сервері, а не в самому Gemini CLI. Він працює шляхом
перехоплення запитів на аутентифікацію до Google та додавання спеціального
HTTP-заголовка.

Ця політика заважає користувачам входити з особистих акаунтів Gmail або інших
некорпоративних облікових записів.

Детальні інструкції дивіться у довідці адміністратора Google Workspace у статті
про
[блокування доступу до споживчих акаунтів](https://support.google.com/a/answer/1668854?hl=en#zippy=%2Cstep-choose-a-web-proxy-server%2Cstep-configure-the-network-to-block-certain-accounts).

Загальні кроки такі:

1.  **Перехоплення запитів**: Налаштуйте ваш веб-проксі на перехоплення всіх
    запитів до `google.com`.
2.  **Додавання HTTP-заголовка**: Для кожного перехопленого запиту додавайте
    заголовок `X-GoogApps-Allowed-Domains`.
3.  **Вказання доменів**: Значенням заголовка має бути список доменних імен
    вашої організації Google Workspace, розділених комами.

**Приклад заголовка:**

```
X-GoogApps-Allowed-Domains: my-corporate-domain.com, secondary-domain.com
```

Коли цей заголовок присутній, служба аутентифікації Google дозволить вхід лише з
облікових записів, що належать до вказаних доменів.

## Підсумок: приклад системного `settings.json`

Ось приклад системного файлу `settings.json`, який поєднує кілька обговорених
вище патернів для створення безпечного, контрольованого середовища Gemini CLI.

```json
{
  "tools": {
    "sandbox": "docker",
    "core": [
      "ReadFileTool",
      "GlobTool",
      "ShellTool(ls)",
      "ShellTool(cat)",
      "ShellTool(grep)"
    ]
  },
  "mcp": {
    "allowed": ["corp-tools"]
  },
  "mcpServers": {
    "corp-tools": {
      "command": "/opt/gemini-tools/start.sh",
      "timeout": 5000
    }
  },
  "telemetry": {
    "enabled": true,
    "target": "gcp",
    "otlpEndpoint": "https://telemetry-prod.example.com:4317",
    "logPrompts": false
  },
  "advanced": {
    "bugCommand": {
      "urlTemplate": "https://servicedesk.example.com/new-ticket?title={title}&details={info}"
    }
  },
  "privacy": {
    "usageStatisticsEnabled": false
  }
}
```

Ця конфігурація:

- Примусово виконує всі інструменти в пісочниці Docker.
- Суворо використовує білий список для невеликого набору безпечних команд
  оболонки та інструментів роботи з файлами.
- Визначає та дозволяє єдиний корпоративний сервер MCP для власних інструментів.
- Вмикає телеметрію для аудиту без логування вмісту підказок.
- Перенаправляє команду `/bug` на внутрішню систему тікетів.
- Вимикає загальний збір статистики використання.
