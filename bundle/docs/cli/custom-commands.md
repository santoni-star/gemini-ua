# Власні команди

Власні команди дозволяють зберігати та повторно використовувати ваші улюблені
або найчастіше вживані підказки як персональні ярлики всередині Gemini CLI. Ви
можете створювати команди, специфічні для одного проекту, або глобальні команди,
доступні у всіх ваших проектах, що оптимізує ваш робочий процес та забезпечує
послідовність.

## Розташування файлів та пріоритетність

Gemini CLI виявляє команди у двох місцях, завантажуючи їх у певному порядку:

1.  **Команди користувача (глобальні):** Знаходяться у `~/.gemini/commands/`. Ці
    команди доступні у будь-якому проекті, над яким ви працюєте.
2.  **Команди проекту (локальні):** Знаходяться у
    `<корінь-вашого-проекту>/.gemini/commands/`. Ці команди специфічні для
    поточного проекту і можуть бути додані до системи контролю версій для
    спільного використання вашою командою.

Якщо команда в каталозі проекту має таку ж назву, як і команда в каталозі
користувача, **завжди буде використовуватися команда проекту.** Це дозволяє
проектам перевизначати глобальні команди версіями, специфічними для проекту.

## Іменування та простори назв

Назва команди визначається шляхом до її файлу відносно каталогу `commands`.
Підкаталоги використовуються для створення команд у просторах назв, причому
роздільник шляху (`/` або `\`) перетворюється на двокрапку (`:`).

- Файл у `~/.gemini/commands/test.toml` стає командою `/test`.
- Файл у `<project>/.gemini/commands/git/commit.toml` стає командою у просторі
  назв `/git:commit`.

## Формат файлу TOML (v1)

Файли визначення команд мають бути написані у форматі TOML та використовувати
розширення `.toml`.

### Обов'язкові поля

- `prompt` (String): Підказка, яка буде надіслана моделі Gemini при виконанні
  команди. Це може бути однорядковий або багаторядковий рядок.

### Додаткові поля

- `description` (String): Короткий однорядковий опис того, що робить команда.
  Цей текст буде відображатися поруч із вашою командою у меню `/help`. **Якщо ви
  пропустите це поле, загальний опис буде згенеровано з імені файлу.**

## Обробка аргументів

Власні команди підтримують два потужні методи обробки аргументів. CLI
автоматично обирає правильний метод на основі вмісту `prompt` вашої команди.

### 1. Підстановка з урахуванням контексту за допомогою `{{args}}`

Якщо ваш `prompt` містить спеціальний заповнювач `{{args}}`, CLI замінить його
текстом, який користувач ввів після назви команди.

Поведінка цієї підстановки залежить від того, де вона використовується:

**A. Пряма підстановка (поза командами оболонки)**

При використанні в основному тілі підказки, аргументи вставляються саме так, як
їх ввів користувач.

**Приклад (`git/fix.toml`):**

```toml
# Викликається через: /git:fix "Кнопка зміщена"

description = "Генерує виправлення для заданої проблеми."
prompt = "Будь ласка, надайте виправлення коду для проблеми, описаної тут: {{args}}."
```

Модель отримує:
`Будь ласка, надайте виправлення коду для проблеми, описаної тут: "Кнопка зміщена".`

**B. Використання аргументів у командах оболонки (всередині блоків `!{...}`)**

Коли ви використовуєте `{{args}}` всередині блоку підстановки оболонки
(`!{...}`), аргументи автоматично **екрануються для оболонки** перед заміною. Це
дозволяє безпечно передавати аргументи командам оболонки, гарантуючи, що
результуюча команда буде синтаксично правильною та безпечною, запобігаючи
вразливостям до ін'єкцій команд.

**Приклад (`/grep-code.toml`):**

```toml
prompt = """
Будь ласка, підсумуй результати для шаблону `{{args}}`.

Результати пошуку:
!{grep -r {{args}} .}
"""
```

Коли ви запускаєте `/grep-code "складний випадок"`:

1. CLI бачить `{{args}}`, що використовується як зовні, так і всередині
   `!{...}`.
2. Зовні: Перший `{{args}}` замінюється безпосередньо на `складний випадок`.
3. Всередині: Другий `{{args}}` замінюється на екрановану версію (наприклад, на
   Linux: `"складний випадок"`).
4. Виконується команда `grep -r "складний випадок" .`.
5. CLI просить вас підтвердити цю точну, безпечну команду перед виконанням.
6. Остаточна підказка надсилається моделі.

### 2. Обробка аргументів за замовчуванням

Якщо ваш `prompt` **не містить** спеціального заповнювача `{{args}}`, CLI
використовує стандартну поведінку для обробки аргументів.

Якщо ви надаєте аргументи команді (наприклад, `/mycommand arg1`), CLI додасть
повну команду, яку ви ввели, в кінець підказки, розділивши їх двома новими
рядками. Це дозволяє моделі бачити як оригінальні інструкції, так і специфічні
аргументи, які ви щойно надали.

Якщо ви **не надаєте** жодних аргументів (наприклад, `/mycommand`), підказка
надсилається моделі саме так, як вона є, нічого не додаючи.

**Приклад (`changelog.toml`):**

Цей приклад показує, як створити надійну команду, визначивши роль для моделі,
пояснивши, де знайти ввід користувача, та вказавши очікуваний формат і
поведінку.

```toml
# У: <project>/.gemini/commands/changelog.toml
# Викликається через: /changelog 1.2.0 added "Підтримка парсингу аргументів за замовчуванням."

description = "Додає новий запис у файл CHANGELOG.md проекту."
prompt = """
# Завдання: Оновити Changelog

Ви — експерт-супроводжувач цього програмного проекту. Користувач викликав команду, щоб додати новий запис у список змін (changelog).

**Пряма команда користувача додана нижче ваших інструкцій.**

Ваше завдання — розібрати `<version>`, `<change_type>` та `<message>` з їхнього вводу та використовувати інструмент `write_file` для коректного оновлення файлу `CHANGELOG.md`.

## Очікуваний формат
Команда має такий формат: `/changelog <version> <type> <message>`
- `<type>` має бути одним із: "added", "changed", "fixed", "removed".

## Поведінка
1. Прочитайте файл `CHANGELOG.md`.
2. Знайдіть розділ для вказаної версії `<version>`.
3. Додайте `<message>` під відповідним заголовком `<type>`.
4. Якщо розділ версії або типу не існує, створіть його.
5. Суворо дотримуйтеся формату "Keep a Changelog".
"""
```

Коли ви запустите `/changelog 1.2.0 added "Нова функція"`, остаточний текст,
надісланий моделі, буде оригінальною підказкою, за якою слідують два нові рядки
та введена вами команда.

### 3. Виконання команд оболонки за допомогою `!{...}`

Ви можете зробити свої команди динамічними, виконуючи команди оболонки
безпосередньо у вашому `prompt` та вставляючи їхній вивід. Це ідеально підходить
для збору контексту з вашого локального середовища, наприклад, читання вмісту
файлів або перевірки статусу Git.

Коли власна команда намагається виконати команду оболонки, Gemini CLI тепер
запитає у вас підтвердження перед продовженням. Це захід безпеки, щоб
гарантувати виконання лише запланованих команд.

**Як це працює:**

1.  **Вставка команд:** Використовуйте синтаксис `!{...}`.
2.  **Заміна аргументів:** Якщо `{{args}}` присутній всередині блоку, він
    автоматично екранується для оболонки (див.
    [Підстановка з урахуванням контексту](#1-підстановка-з-урахуванням-контексту-за-допомогою-args)
    вище).
3.  **Надійний парсинг:** Парсер коректно обробляє складні команди оболонки, які
    містять вкладені фігурні дужки, наприклад, корисні навантаження JSON.
    **Примітка:** Вміст всередині `!{...}` повинен мати збалансовані фігурні
    дужки (`{` та `}`). Якщо вам потрібно виконати команду, що містить
    незбалансовані дужки, розгляньте можливість її винесення у зовнішній файл
    сценарію та виклику цього сценарію всередині блоку `!{...}`.
4.  **Перевірка безпеки та підтвердження:** CLI виконує перевірку безпеки
    остаточної, вирішеної команди (після екранування та заміни аргументів).
    З'явиться діалогове вікно з точними командами, що будуть виконані.
5.  **Виконання та звіт про помилки:** Команда виконується. Якщо команда
    завершується невдало, вивід, вставлений у підказку, включатиме повідомлення
    про помилки (stderr), за якими слідуватиме рядок статусу, наприклад,
    `[Команда оболонки завершилася з кодом 1]`.

**Приклад (`git/commit.toml`):**

Ця команда отримує підготовлені (staged) зміни git і використовує їх, щоб
попросити модель написати повідомлення коміту.

````toml
# У: <project>/.gemini/commands/git/commit.toml
# Викликається через: /git:commit

description = "Генерує повідомлення коміту Git на основі підготовлених змін."

# Підказка використовує !{...} для виконання команди та вставки її виводу.
prompt = """
Будь ласка, згенеруй повідомлення Conventional Commit на основі наступного git diff:

```diff
!{git diff --staged}
```

"""
````

Коли ви запускаєте `/git:commit`, CLI спочатку виконує `git diff --staged`,
потім замінює `!{git diff --staged}` виводом цієї команди перед відправкою
остаточної, повної підказки моделі.

### 4. Вставка вмісту файлів за допомогою `@{...}`

Ви можете безпосередньо вбудовувати вміст файлу або список файлів каталогу у
вашу підказку за допомогою синтаксису `@{...}`. Це корисно для створення команд,
які працюють з конкретними файлами.

**Як це працює:**

- **Вставка файлу**: `@{path/to/file.txt}` замінюється вмістом `file.txt`.
- **Мультимодальна підтримка**: Якщо шлях вказує на підтримуване зображення
  (наприклад, PNG, JPEG), PDF, аудіо або відеофайл, він буде коректно кодований
  та вставлений як мультимодальний ввід. Інші бінарні файли обробляються
  коректно і пропускаються.
- **Список каталогу**: `@{path/to/dir}` проходить по каталогу, і кожен файл у
  цьому каталозі та всіх підкаталогах вставляється у підказку. Це враховує
  `.gitignore` та `.geminiignore`, якщо вони увімкнені.
- **Врахування робочого простору**: Команда шукає шлях у поточному каталозі та
  будь-яких інших каталогах робочого простору. Абсолютні шляхи дозволені, якщо
  вони знаходяться в межах робочого простору.
- **Порядок обробки**: Вставка вмісту файлів за допомогою `@{...}` обробляється
  _перед_ командами оболонки (`!{...}`) та заміною аргументів (`{{args}}`).
- **Парсинг**: Парсер вимагає, щоб вміст всередині `@{...}` (шлях) мав
  збалансовані фігурні дужки (`{` та `}`).

**Приклад (`review.toml`):**

Ця команда вставляє вміст _фіксованого_ файлу з кращими практиками
(`docs/best-practices.md`) і використовує аргументи користувача для надання
контексту для огляду.

```toml
# У: <project>/.gemini/commands/review.toml
# Викликається через: /review FileCommandLoader.ts

description = "Переглядає наданий контекст, використовуючи посібник з кращих практик."
prompt = """
Ви — експертний рецензент коду.

Ваше завдання — переглянути {{args}}.

Використовуйте наступні кращі практики при проведенні огляду:

@{docs/best-practices.md}
"""
```

Коли ви запускаєте `/review FileCommandLoader.ts`, заповнювач
`@{docs/best-practices.md}` замінюється вмістом цього файлу, а `{{args}}`
замінюється наданим вами текстом, перш ніж остаточна підказка буде надіслана
моделі.

---

## Приклад: Команда рефакторингу "Чиста функція"

Давайте створимо глобальну команду, яка просить модель рефакторити фрагмент
коду.

**1. Створіть файл та каталоги:**

Спочатку переконайтеся, що каталог команд користувача існує, потім створіть
підкаталог `refactor` для організації та фінальний файл TOML.

```bash
mkdir -p ~/.gemini/commands/refactor
touch ~/.gemini/commands/refactor/pure.toml
```

**2. Додайте вміст у файл:**

Відкрийте `~/.gemini/commands/refactor/pure.toml` у вашому редакторі та додайте
наступний вміст. Ми включаємо необов'язковий `description` як кращу практику.

```toml
# У: ~/.gemini/commands/refactor/pure.toml
# Ця команда буде викликатися через: /refactor:pure

description = "Просить модель рефакторити поточний контекст у чисту функцію."

prompt = """
Будь ласка, проаналізуй код, який я надав у поточному контексті.
Рефактори його у чисту функцію (pure function).

Твоя відповідь має містити:
1. Блок коду з рефактореною чистою функцією.
2. Коротке пояснення основних змін, які ти вніс, і чому вони сприяють чистоті функції.
"""
```

**3. Запустіть команду:**

Це все! Тепер ви можете запустити свою команду в CLI. Спочатку ви можете додати
файл до контексту, а потім викликати свою команду:

```
> @my-messy-function.js
> /refactor:pure
```

Gemini CLI виконає багаторядкову підказку, визначену у вашому TOML-файлі.

```

```
